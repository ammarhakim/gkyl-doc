
<style>/*! pygments syntax highlighting */pre{line-height:125%;}td.linenos pre{color:#000000; background-color:#f0f0f0; padding-left:5px; padding-right:5px;}span.linenos{color:#000000; background-color:#f0f0f0; padding-left:5px; padding-right:5px;}td.linenos pre.special{color:#000000; background-color:#ffffc0; padding-left:5px; padding-right:5px;}span.linenos.special{color:#000000; background-color:#ffffc0; padding-left:5px; padding-right:5px;}.pdoc .hll{background-color:#ffffcc}.pdoc{background:#f8f8f8;}.pdoc .c{color:#408080; font-style:italic}.pdoc .err{border:1px solid #FF0000}.pdoc .k{color:#008000; font-weight:bold}.pdoc .o{color:#666666}.pdoc .ch{color:#408080; font-style:italic}.pdoc .cm{color:#408080; font-style:italic}.pdoc .cp{color:#BC7A00}.pdoc .cpf{color:#408080; font-style:italic}.pdoc .c1{color:#408080; font-style:italic}.pdoc .cs{color:#408080; font-style:italic}.pdoc .gd{color:#A00000}.pdoc .ge{font-style:italic}.pdoc .gr{color:#FF0000}.pdoc .gh{color:#000080; font-weight:bold}.pdoc .gi{color:#00A000}.pdoc .go{color:#888888}.pdoc .gp{color:#000080; font-weight:bold}.pdoc .gs{font-weight:bold}.pdoc .gu{color:#800080; font-weight:bold}.pdoc .gt{color:#0044DD}.pdoc .kc{color:#008000; font-weight:bold}.pdoc .kd{color:#008000; font-weight:bold}.pdoc .kn{color:#008000; font-weight:bold}.pdoc .kp{color:#008000}.pdoc .kr{color:#008000; font-weight:bold}.pdoc .kt{color:#B00040}.pdoc .m{color:#666666}.pdoc .s{color:#BA2121}.pdoc .na{color:#7D9029}.pdoc .nb{color:#008000}.pdoc .nc{color:#0000FF; font-weight:bold}.pdoc .no{color:#880000}.pdoc .nd{color:#AA22FF}.pdoc .ni{color:#999999; font-weight:bold}.pdoc .ne{color:#D2413A; font-weight:bold}.pdoc .nf{color:#0000FF}.pdoc .nl{color:#A0A000}.pdoc .nn{color:#0000FF; font-weight:bold}.pdoc .nt{color:#008000; font-weight:bold}.pdoc .nv{color:#19177C}.pdoc .ow{color:#AA22FF; font-weight:bold}.pdoc .w{color:#bbbbbb}.pdoc .mb{color:#666666}.pdoc .mf{color:#666666}.pdoc .mh{color:#666666}.pdoc .mi{color:#666666}.pdoc .mo{color:#666666}.pdoc .sa{color:#BA2121}.pdoc .sb{color:#BA2121}.pdoc .sc{color:#BA2121}.pdoc .dl{color:#BA2121}.pdoc .sd{color:#BA2121; font-style:italic}.pdoc .s2{color:#BA2121}.pdoc .se{color:#BB6622; font-weight:bold}.pdoc .sh{color:#BA2121}.pdoc .si{color:#BB6688; font-weight:bold}.pdoc .sx{color:#008000}.pdoc .sr{color:#BB6688}.pdoc .s1{color:#BA2121}.pdoc .ss{color:#19177C}.pdoc .bp{color:#008000}.pdoc .fm{color:#0000FF}.pdoc .vc{color:#19177C}.pdoc .vg{color:#19177C}.pdoc .vi{color:#19177C}.pdoc .vm{color:#19177C}.pdoc .il{color:#666666}</style>
<style>/*! pdoc */:root{--pdoc-background:#fff;}.pdoc{--text:#212529;--muted:#6c757d;--link:#3660a5;--link-hover:#1659c5;--code:#f7f7f7;--active:#fff598;--accent:#eee;--accent2:#c1c1c1;--nav-hover:rgba(255, 255, 255, 0.5);--name:#0066BB;--def:#008800;--annotation:#007020;}html, main{scroll-behavior:smooth;}.pdoc{color:var(--text);box-sizing:border-box;line-height:1.5;background:none;}.pdoc .pdoc-button{display:inline-block;border:solid black 1px;border-radius:2px;font-size:.75rem;padding:calc(0.5em - 1px) 1em;transition:100ms all;}.pdoc .visually-hidden{position:absolute !important;width:1px !important;height:1px !important;padding:0 !important;margin:-1px !important;overflow:hidden !important;clip:rect(0, 0, 0, 0) !important;white-space:nowrap !important;border:0 !important;}.pdoc h1, .pdoc h2, .pdoc h3{font-weight:300;margin:.3em 0;padding:.2em 0;}.pdoc a{text-decoration:none;color:var(--link);}.pdoc a:hover{color:var(--link-hover);}.pdoc blockquote{margin-left:2rem;}.pdoc pre{background-color:var(--code);border-top:1px solid var(--accent2);border-bottom:1px solid var(--accent2);margin-bottom:1em;padding:.5rem 0 .5rem .5rem;overflow-x:auto;}.pdoc code{color:var(--text);padding:.2em .4em;margin:0;font-size:85%;background-color:var(--code);border-radius:6px;}.pdoc a > code{color:inherit;}.pdoc pre > code{display:inline-block;font-size:inherit;background:none;border:none;padding:0;}.pdoc .modulename{margin-top:0;font-weight:bold;}.pdoc .modulename a{color:var(--link);transition:100ms all;}.pdoc .git-button{float:right;border:solid var(--link) 1px;}.pdoc .git-button:hover{background-color:var(--link);color:var(--pdoc-background);}.pdoc details{--shift:-40px;text-align:right;margin-top:var(--shift);margin-bottom:calc(0px - var(--shift));clear:both;filter:opacity(1);}.pdoc details:not([open]){height:0;overflow:visible;}.pdoc details > summary{font-size:.75rem;cursor:pointer;color:var(--muted);border-width:0;padding:0 .7em;display:inline-block;display:inline list-item;user-select:none;}.pdoc details > summary:focus{outline:0;}.pdoc details > div{margin-top:calc(0px - var(--shift) / 2);text-align:left;}.pdoc .docstring{margin-bottom:1.5rem;}.pdoc > section:first-of-type > .docstring{margin-bottom:3rem;}.pdoc .docstring pre{margin-left:1em;margin-right:1em;}.pdoc h1:target,.pdoc h2:target,.pdoc h3:target,.pdoc h4:target,.pdoc h5:target,.pdoc h6:target{background-color:var(--active);box-shadow:-1rem 0 0 0 var(--active);}.pdoc div:target > .attr,.pdoc section:target > .attr,.pdoc dd:target > a{background-color:var(--active);}.pdoc .attr:hover{filter:contrast(0.95);}.pdoc .headerlink{position:absolute;width:0;margin-left:-1.5rem;line-height:1.4rem;font-size:1.5rem;font-weight:normal;transition:all 100ms ease-in-out;opacity:0;}.pdoc .attr > .headerlink{margin-left:-2.5rem;}.pdoc *:hover > .headerlink,.pdoc *:target > .attr > .headerlink{opacity:1;}.pdoc .attr{display:block;color:var(--text);margin:1rem 0 .5rem;padding:.4rem 5rem .4rem 1rem;background-color:var(--accent);}.pdoc .classattr{margin-left:2rem;}.pdoc .name{color:var(--name);font-weight:bold;}.pdoc .def{color:var(--def);font-weight:bold;}.pdoc .signature{white-space:pre-wrap;}.pdoc .annotation{color:var(--annotation);}.pdoc .inherited{margin-left:2rem;}.pdoc .inherited dt{font-weight:700;}.pdoc .inherited dt, .pdoc .inherited dd{display:inline;margin-left:0;margin-bottom:.5rem;}.pdoc .inherited dd:not(:last-child):after{content:", ";}.pdoc .inherited .class:before{content:"class ";}.pdoc .inherited .function a:after{content:"()";}.pdoc .search-result .docstring{overflow:auto;max-height:25vh;}.pdoc .search-result.focused > .attr{background-color:var(--active);}.pdoc .attribution{margin-top:2rem;display:block;opacity:0.5;transition:all 200ms;filter:grayscale(100%);}.pdoc .attribution:hover{opacity:1;filter:grayscale(0%);}.pdoc .attribution img{margin-left:5px;height:35px;vertical-align:middle;width:70px;transition:all 200ms;}</style>    <main class="pdoc">
            <section>
                    <h1 class="modulename">
<a href="./../../postgkyl.html">postgkyl</a><wbr>.<a href="./../data.html">data</a><wbr>.dg    </h1>

                
                        <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="nn">os.path</span>
<span class="kn">from</span> <span class="nn">glob</span> <span class="kn">import</span> <span class="n">glob</span>

<span class="kn">import</span> <span class="nn">tables</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">postgkyl.data.data</span> <span class="kn">import</span> <span class="n">Data</span>
<span class="kn">from</span> <span class="nn">postgkyl.data.computeInterpolationMatrices</span> <span class="kn">import</span> <span class="n">createInterpMatrix</span>
<span class="kn">from</span> <span class="nn">postgkyl.data.computeDerivativeMatrices</span> <span class="kn">import</span> <span class="n">createDerivativeMatrix</span>

<span class="kn">from</span> <span class="nn">postgkyl.data.recovData</span> <span class="kn">import</span> <span class="n">recovC0Fn</span><span class="p">,</span> <span class="n">recovC1Fn</span><span class="p">,</span> <span class="n">recovEdFn</span>

<span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="vm">__file__</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_getNumNodes</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">polyOrder</span><span class="p">,</span> <span class="n">basisType</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">basisType</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;serendipity&#39;</span><span class="p">:</span>
        <span class="n">numNodesSerendipity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>   <span class="mi">3</span><span class="p">,</span>   <span class="mi">4</span><span class="p">,</span>   <span class="mi">5</span><span class="p">],</span>
                                        <span class="p">[</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span>   <span class="mi">8</span><span class="p">,</span>  <span class="mi">12</span><span class="p">,</span>  <span class="mi">17</span><span class="p">],</span>
                                        <span class="p">[</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span>  <span class="mi">20</span><span class="p">,</span>  <span class="mi">32</span><span class="p">,</span>  <span class="mi">50</span><span class="p">],</span>
                                        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span>  <span class="mi">48</span><span class="p">,</span>  <span class="mi">80</span><span class="p">,</span> <span class="mi">136</span><span class="p">],</span>
                                        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">112</span><span class="p">,</span> <span class="mi">192</span><span class="p">,</span> <span class="mi">352</span><span class="p">],</span>
                                        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">448</span><span class="p">,</span> <span class="mi">880</span><span class="p">]])</span>
        <span class="n">numNodes</span> <span class="o">=</span> <span class="n">numNodesSerendipity</span><span class="p">[</span><span class="n">dim</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">polyOrder</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">basisType</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;maximal-order&#39;</span><span class="p">:</span>
        <span class="n">numNodesMaximal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span>   <span class="mi">5</span><span class="p">],</span>
                                    <span class="p">[</span><span class="mi">3</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span>  <span class="mi">15</span><span class="p">],</span>
                                    <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span>  <span class="mi">35</span><span class="p">],</span>
                                    <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span>  <span class="mi">70</span><span class="p">],</span>
                                    <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">126</span><span class="p">]],</span>
                                    <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">84</span><span class="p">,</span> <span class="mi">210</span><span class="p">])</span>
        <span class="n">numNodes</span> <span class="o">=</span> <span class="n">numNodesMaximal</span><span class="p">[</span><span class="n">dim</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">polyOrder</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">basisType</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;tensor&#39;</span><span class="p">:</span>
        <span class="n">numNodesMaximal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="mi">2</span><span class="p">,</span>   <span class="mi">3</span><span class="p">,</span>    <span class="mi">4</span><span class="p">,</span>     <span class="mi">5</span><span class="p">],</span>
                                    <span class="p">[</span> <span class="mi">4</span><span class="p">,</span>   <span class="mi">9</span><span class="p">,</span>   <span class="mi">16</span><span class="p">,</span>    <span class="mi">25</span><span class="p">],</span>
                                    <span class="p">[</span> <span class="mi">8</span><span class="p">,</span>  <span class="mi">27</span><span class="p">,</span>   <span class="mi">64</span><span class="p">,</span>   <span class="mi">125</span><span class="p">],</span>
                                    <span class="p">[</span><span class="mi">16</span><span class="p">,</span>  <span class="mi">81</span><span class="p">,</span>  <span class="mi">256</span><span class="p">,</span>   <span class="mi">625</span><span class="p">],</span>
                                    <span class="p">[</span><span class="mi">32</span><span class="p">,</span> <span class="mi">343</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span>  <span class="mi">3125</span><span class="p">],</span>
                                    <span class="p">[</span><span class="mi">64</span><span class="p">,</span> <span class="mi">729</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span> <span class="mi">15625</span><span class="p">]])</span>
        <span class="n">numNodes</span> <span class="o">=</span> <span class="n">numNodesMaximal</span><span class="p">[</span><span class="n">dim</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">polyOrder</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span>
            <span class="s2">&quot;GInterp: Basis &#39;</span><span class="si">{:s}</span><span class="s2">&#39; is not supported!</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;Supported basis are currently &#39;ns&#39; (Nodal Serendipity),&quot;</span>
            <span class="s2">&quot; &#39;ms&#39; (Modal Serendipity), &#39;mt&#39; (Modal Tensor product),&quot;</span>
            <span class="s2">&quot; and &#39;mo&#39; (Modal maximal Order)&quot;</span><span class="o">.</span>
            <span class="nb">format</span><span class="p">(</span><span class="n">basisType</span><span class="p">))</span>
    <span class="c1">#end</span>
    <span class="k">return</span> <span class="n">numNodes</span>
<span class="c1">#end</span>


<span class="k">def</span> <span class="nf">_loadInterpMatrix</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">polyOrder</span><span class="p">,</span> <span class="n">basisType</span><span class="p">,</span> <span class="n">interp</span><span class="p">,</span> <span class="n">read</span><span class="p">,</span> <span class="n">modal</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">interp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">read</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">createInterpMatrix</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">polyOrder</span><span class="p">,</span> <span class="n">basisType</span><span class="p">,</span> <span class="n">interp</span><span class="p">,</span> <span class="n">modal</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mat</span>
    <span class="k">elif</span> <span class="n">basisType</span><span class="o">==</span><span class="s1">&#39;tensor&#39;</span><span class="p">:</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">createInterpMatrix</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">polyOrder</span><span class="p">,</span> <span class="s1">&#39;tensor&#39;</span><span class="p">,</span> <span class="n">polyOrder</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mat</span>
    <span class="k">elif</span> <span class="n">read</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fileNameGeneral</span> <span class="o">=</span> <span class="n">postgkylPath</span> <span class="o">+</span> <span class="s1">&#39;/interpMatrix.h5&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">fileNameGeneral</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;interpMatrix.h5 not found, creating interpolation matrix</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">interp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;interp = </span><span class="si">{}</span><span class="s2">, calling createInterpMatrix for dim = </span><span class="si">{}</span><span class="s2">,&quot;</span>
                      <span class="s2">&quot; basisType = </span><span class="si">{}</span><span class="s2">, and polyOrder = </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span>
                      <span class="nb">format</span><span class="p">(</span><span class="n">interp</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">basisType</span><span class="p">,</span> <span class="n">polyOrder</span><span class="p">))</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="n">createInterpMatrix</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">polyOrder</span><span class="p">,</span> <span class="n">basisType</span><span class="p">,</span> <span class="n">interp</span><span class="p">,</span> <span class="n">modal</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">mat</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;interp not specified, reading from pre-computed&quot;</span>
                      <span class="s2">&quot; files for dim = </span><span class="si">{}</span><span class="s2">, basisType = </span><span class="si">{}</span><span class="s2">, and polyOrder = </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span>
                      <span class="nb">format</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">basisType</span><span class="p">,</span> <span class="n">polyOrder</span><span class="p">))</span>
                <span class="c1"># Load interpolation matrix from the pre-computed HDF5</span>
                <span class="c1"># file since interp not specified.</span>
                <span class="n">varid</span> <span class="o">=</span> <span class="s2">&quot;xformMatrix</span><span class="si">{:d}{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">polyOrder</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">modal</span> <span class="o">==</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">basisType</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;serendipity&#39;</span><span class="p">:</span>
                    <span class="n">fileName</span> <span class="o">=</span> <span class="n">path</span> <span class="o">+</span> <span class="s1">&#39;/xformMatricesNodalSerendipity.h5&#39;</span>
                <span class="k">elif</span> <span class="n">modal</span> <span class="ow">and</span> <span class="n">basisType</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;serendipity&#39;</span><span class="p">:</span>
                    <span class="n">fileName</span> <span class="o">=</span> <span class="n">path</span> <span class="o">+</span> <span class="s1">&#39;/xformMatricesModalSerendipity.h5&#39;</span>
                <span class="k">elif</span> <span class="n">modal</span> <span class="ow">and</span> <span class="n">basisType</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;maximal-order&#39;</span><span class="p">:</span>
                    <span class="n">fileName</span> <span class="o">=</span> <span class="n">path</span> <span class="o">+</span> <span class="s1">&#39;/xformMatricesModalMaximal.h5&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span>
                        <span class="s2">&quot;GInterp: BasisType </span><span class="si">{}</span><span class="s2"> is not supported!</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="s2">&quot;Supported basisType are currently &#39;ns&#39;&quot;</span>
                        <span class="s2">&quot; (Nodal Serendipity), &#39;ms&#39; (Modal Serendipity),&quot;</span>
                        <span class="s2">&quot; and &#39;mo&#39; (Modal Maximal Order)&quot;</span><span class="o">.</span>
                        <span class="nb">format</span><span class="p">(</span><span class="n">basisType</span><span class="p">))</span>
                <span class="n">fh</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">open_file</span><span class="p">(</span><span class="n">fileName</span><span class="p">)</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fh</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">matrices</span><span class="o">.</span><span class="n">_v_children</span><span class="p">[</span><span class="n">varid</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
                <span class="n">fh</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">mat</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
            <span class="c1">#end</span>
        <span class="c1">#end</span>
                
        <span class="n">fhGeneral</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">open_file</span><span class="p">(</span><span class="n">postgkylPath</span><span class="o">+</span><span class="s1">&#39;/interpMatrix.h5&#39;</span><span class="p">,</span>
                                     <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>        
        <span class="n">mat</span> <span class="o">=</span> <span class="n">fhGeneral</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">interpolation_matrix</span><span class="p">[:]</span>
        <span class="n">fhGeneral</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        
        <span class="c1"># Check if matrix loaded from interpMatrix.h5 has correct first</span>
        <span class="c1"># dimension (i.e. has correct number of nodes)</span>
        
        <span class="n">numNodes</span> <span class="o">=</span> <span class="n">_getNumNodes</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">polyOrder</span><span class="p">,</span> <span class="n">basisType</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">numNodes</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;WARNING: Matrix read from interpMatrix.h5&quot;</span>
                  <span class="s2">&quot; does not have the right dimensions for specified &quot;</span>
                  <span class="s2">&quot;dim = </span><span class="si">{:d}</span><span class="s2">, basis = </span><span class="si">{:d}</span><span class="s2">, and polyOrder = </span><span class="si">{:d}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span>
                  <span class="nb">format</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">basisType</span><span class="p">,</span> <span class="n">polyOrder</span><span class="p">))</span>
            
            <span class="k">if</span> <span class="n">interp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;interp = </span><span class="si">{}</span><span class="s2">, calling createInterpMatrix &quot;</span>
                <span class="s2">&quot;for dim = </span><span class="si">{:d}</span><span class="s2">, basis = </span><span class="si">{:d}</span><span class="s2">, and polyOrder = </span><span class="si">{:d}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span>
                      <span class="nb">format</span><span class="p">(</span><span class="n">interp</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">basisType</span><span class="p">,</span> <span class="n">polyOrder</span><span class="p">))</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="n">createInterpMatrix</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">polyOrder</span><span class="p">,</span> <span class="n">basisType</span><span class="p">,</span> <span class="n">interp</span><span class="p">,</span> <span class="n">modal</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">mat</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;interp not specified, reading from pre-computed &quot;</span>
                      <span class="s2">&quot;files for dim = </span><span class="si">{:d}</span><span class="s2">, basis = </span><span class="si">{:d}</span><span class="s2">, &quot;</span>
                      <span class="s2">&quot;and polyOrder = </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span>
                      <span class="nb">format</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">basisType</span><span class="p">,</span> <span class="n">polyOrder</span><span class="p">))</span>
                <span class="c1"># Load interpolation matrix from the pre-computed HDF5</span>
                <span class="c1"># file since interp not specified.</span>
                <span class="n">varid</span> <span class="o">=</span> <span class="s2">&quot;xformMatrix</span><span class="si">{:d}{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">polyOrder</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">modal</span> <span class="o">==</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">basisType</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;serendipity&#39;</span><span class="p">:</span>
                    <span class="n">fileName</span> <span class="o">=</span> <span class="n">path</span> <span class="o">+</span> <span class="s1">&#39;/xformMatricesNodalSerendipity.h5&#39;</span>
                <span class="k">elif</span> <span class="n">modal</span> <span class="ow">and</span> <span class="n">basisType</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;serendipity&#39;</span><span class="p">:</span>
                    <span class="n">fileName</span> <span class="o">=</span> <span class="n">path</span> <span class="o">+</span> <span class="s1">&#39;/xformMatricesModalSerendipity.h5&#39;</span>
                <span class="k">elif</span> <span class="n">modal</span> <span class="ow">and</span> <span class="n">basisType</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;serendipity&#39;</span><span class="p">:</span>
                    <span class="n">fileName</span> <span class="o">=</span> <span class="n">path</span> <span class="o">+</span> <span class="s1">&#39;/xformMatricesModalMaximal.h5&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span>
                        <span class="s2">&quot;GInterp: Basis </span><span class="si">{}</span><span class="s2"> is not supported!</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="s2">&quot;Supported basis are currently &#39;ns&#39; &quot;</span>
                        <span class="s2">&quot;(Nodal Serendipity), &#39;ms&#39; (Modal Serendipity), &quot;</span>
                        <span class="s2">&quot;and &#39;mo&#39; (Modal Maximal Order)&quot;</span><span class="o">.</span>
                        <span class="nb">format</span><span class="p">(</span><span class="n">basis</span><span class="p">))</span>
                <span class="c1">#end</span>
                <span class="n">fh</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">open_file</span><span class="p">(</span><span class="n">fileName</span><span class="p">)</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="n">fh</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">matrices</span><span class="o">.</span><span class="n">_v_children</span><span class="p">[</span><span class="n">varid</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
                <span class="n">fh</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">mat</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
            <span class="c1">#end</span>
        <span class="c1">#end</span>
        <span class="k">return</span> <span class="n">mat</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Load interpolation matrix from the pre-computed HDF5 file.</span>
        <span class="n">varid</span> <span class="o">=</span> <span class="s1">&#39;xformMatrix</span><span class="si">%i%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">polyOrder</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">modal</span> <span class="o">==</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">basisType</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;serendipity&#39;</span><span class="p">:</span>
            <span class="n">fileName</span> <span class="o">=</span> <span class="n">path</span> <span class="o">+</span> <span class="s1">&#39;/xformMatricesNodalSerendipity.h5&#39;</span>
        <span class="k">elif</span> <span class="n">modal</span> <span class="ow">and</span> <span class="n">basisType</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;serendipity&#39;</span><span class="p">:</span>
            <span class="n">fileName</span> <span class="o">=</span> <span class="n">path</span> <span class="o">+</span> <span class="s1">&#39;/xformMatricesModalSerendipity.h5&#39;</span>

        <span class="k">elif</span> <span class="n">modal</span> <span class="ow">and</span> <span class="n">basisType</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;maximal-order&#39;</span><span class="p">:</span>
            <span class="n">fileName</span> <span class="o">=</span> <span class="n">path</span> <span class="o">+</span> <span class="s1">&#39;/xformMatricesModalMaximal.h5&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span>
                <span class="s2">&quot;GInterp: Basis </span><span class="si">{:s}</span><span class="s2"> is not supported!</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;Supported basis are currently &#39;ns&#39; (Nodal Serendipity), &quot;</span>
                <span class="s2">&quot;&#39;ms&#39; (Modal Serendipity), and &#39;mo&#39; (Modal Maximal Order)&quot;</span><span class="o">.</span>
                <span class="nb">format</span><span class="p">(</span><span class="n">basisType</span><span class="p">))</span>
        <span class="c1">#end</span>
        <span class="n">fh</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">open_file</span><span class="p">(</span><span class="n">fileName</span><span class="p">)</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">fh</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">matrices</span><span class="o">.</span><span class="n">_v_children</span><span class="p">[</span><span class="n">varid</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="n">fh</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">mat</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="c1">#end</span>
<span class="c1">#end</span>


<span class="k">def</span> <span class="nf">_loadDerivativeMatrix</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">polyOrder</span><span class="p">,</span> <span class="n">basisType</span><span class="p">,</span> <span class="n">interp</span><span class="p">,</span> <span class="n">read</span><span class="p">,</span> <span class="n">modal</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">interp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">read</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">createDerivativeMatrix</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">polyOrder</span><span class="p">,</span> <span class="n">basisType</span><span class="p">,</span> <span class="n">interp</span><span class="p">,</span> <span class="n">modal</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mat</span>
    <span class="k">elif</span> <span class="n">read</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fileNameGeneral</span> <span class="o">=</span> <span class="n">postgkylPath</span> <span class="o">+</span> <span class="s1">&#39;/derivativeMatrix.h5&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">fileNameGeneral</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;derivativeMatrix.h5 not found, creating derivative matrix</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">interp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;interp = </span><span class="si">{}</span><span class="s1">, calling createDerivativeMatrix for dim = </span><span class="si">{}</span><span class="s1">, basis = </span><span class="si">{}</span><span class="s1">, and polyOrder = </span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">interp</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">basisType</span><span class="p">,</span> <span class="n">polyOrder</span><span class="p">))</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="n">createDerivativeMatrix</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">polyOrder</span><span class="p">,</span> <span class="n">basisType</span><span class="p">,</span>
                                             <span class="n">interp</span><span class="p">,</span> <span class="n">modal</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">mat</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;interp not specified, calling createDerivativeMatrix with polyOrder = </span><span class="si">{}</span><span class="s1">+1 level of interpolation</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">polyOrder</span><span class="p">))</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="n">createDerivativeMatrix</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">polyOrder</span><span class="p">,</span> <span class="n">basisType</span><span class="p">,</span> <span class="n">polyOrder</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">mat</span>
            <span class="c1">#end</span>
        <span class="c1">#end</span>
        <span class="n">fhGeneral</span> <span class="o">=</span> <span class="n">tables</span><span class="o">.</span><span class="n">open_file</span><span class="p">(</span><span class="n">postgkylPath</span><span class="o">+</span><span class="s1">&#39;/derivativeMatrix.h5&#39;</span><span class="p">,</span>
                                     <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>        
        <span class="n">mat</span> <span class="o">=</span> <span class="n">fhGeneral</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">derivative_matrix</span><span class="p">[:]</span>
        <span class="n">fhGeneral</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="c1"># Check if matrix loaded from interpMatrix.h5 has correct</span>
        <span class="c1"># first dimension (i.e. has correct number of nodes)</span>
        
        <span class="n">numNodes</span> <span class="o">=</span> <span class="n">_getNumNodes</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">polyOrder</span><span class="p">,</span> <span class="n">basisType</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">numNodes</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;WARNING: Matrix read from derivativeMatrix.h5 does not have the right dimensions for specified dim = </span><span class="si">{}</span><span class="s1">, basis = </span><span class="si">{}</span><span class="s1">, and polyOrder = </span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">basisType</span><span class="p">,</span> <span class="n">polyOrder</span><span class="p">))</span>
            
            <span class="k">if</span> <span class="n">interp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;interp = </span><span class="si">{}</span><span class="s1">, calling createDerivativeMatrix for dim = </span><span class="si">{}</span><span class="s1">, basis = </span><span class="si">{}</span><span class="s1">, and polyOrder = </span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">interp</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">basis</span><span class="p">,</span> <span class="n">polyOrder</span><span class="p">))</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="n">createDerivativeMatrix</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">polyOrder</span><span class="p">,</span> <span class="n">basisType</span><span class="p">,</span>
                                             <span class="n">interp</span><span class="p">,</span> <span class="n">modal</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">mat</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;interp not specified, calling createDerivativeMatrix with polyOrder = </span><span class="si">{}</span><span class="s1">+1 level of interpolation</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">polyOrder</span><span class="p">))</span>
                <span class="n">mat</span> <span class="o">=</span> <span class="n">createDerivativeMatrix</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">polyOrder</span><span class="p">,</span> <span class="n">basisType</span><span class="p">,</span> <span class="n">polyOrder</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">modal</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">mat</span>
            <span class="c1">#end</span>
        <span class="c1">#end</span>
        <span class="k">return</span> <span class="n">mat</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">interp</span> <span class="o">=</span> <span class="n">polyOrder</span><span class="o">+</span><span class="mi">1</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">createDerivativeMatrix</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">polyOrder</span><span class="p">,</span> <span class="n">basisType</span><span class="p">,</span> <span class="n">interp</span><span class="p">,</span> <span class="n">modal</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mat</span>
    <span class="c1">#end</span>
<span class="c1">#end</span>


<span class="k">def</span> <span class="nf">_decompose</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">numInterp</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Decompose n to the number decription with basis numInterp&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span> <span class="o">/</span>
                  <span class="p">(</span><span class="n">numInterp</span><span class="o">**</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dim</span><span class="p">)),</span> <span class="n">numInterp</span><span class="p">)</span>
<span class="c1">#end</span>


<span class="k">def</span> <span class="nf">_makeMesh</span><span class="p">(</span><span class="n">nInterp</span><span class="p">,</span> <span class="n">Xc</span><span class="p">,</span> <span class="n">xlo</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xup</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gridType</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">nx</span> <span class="o">=</span> <span class="n">Xc</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span> <span class="c1"># expecting nodal mesh</span>
    <span class="n">meshOut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nInterp</span><span class="o">*</span><span class="n">nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">gridType</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">gridType</span><span class="o">==</span><span class="s2">&quot;uniform&quot;</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">xlo</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">xup</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">xlo</span> <span class="o">=</span> <span class="n">Xc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">xup</span> <span class="o">=</span> <span class="n">Xc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
      <span class="c1">#end</span>
      <span class="n">meshOut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xlo</span><span class="p">,</span> <span class="n">xup</span><span class="p">,</span> <span class="n">nInterp</span><span class="o">*</span><span class="n">nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">gridType</span><span class="o">==</span><span class="s2">&quot;mapped&quot;</span><span class="p">:</span>
      <span class="c1"># subdivide every cell in Xc into nInterp cells. </span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">):</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="p">(</span><span class="n">Xc</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">Xc</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="n">nInterp</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nInterp</span><span class="p">):</span>
          <span class="n">meshOut</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">nInterp</span><span class="o">+</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">Xc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">j</span><span class="o">*</span><span class="n">dx</span>
      <span class="c1"># add the last node.</span>
      <span class="n">dx</span> <span class="o">=</span> <span class="p">(</span><span class="n">Xc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">Xc</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">nInterp</span>
      <span class="n">meshOut</span><span class="p">[</span><span class="n">nx</span><span class="o">*</span><span class="n">nInterp</span><span class="p">]</span> <span class="o">=</span> <span class="n">Xc</span><span class="p">[</span><span class="n">nx</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">nInterp</span><span class="o">*</span><span class="n">dx</span>
    <span class="c1">#end</span>
    <span class="k">return</span> <span class="n">meshOut</span>
<span class="c1">#end</span>

<span class="k">def</span> <span class="nf">_make1Dgrids</span><span class="p">(</span><span class="n">nInterp</span><span class="p">,</span> <span class="n">Xc</span><span class="p">,</span> <span class="n">numDims</span><span class="p">,</span> <span class="n">gridType</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="c1"># build a list of 1D arrays, each containing the grid in that dimension.</span>
  <span class="n">gridOut</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span> 
  <span class="k">if</span> <span class="n">gridType</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">gridType</span><span class="o">==</span><span class="s2">&quot;uniform&quot;</span><span class="p">:</span>
    <span class="n">gridOut</span> <span class="o">=</span> <span class="p">[</span><span class="n">_makeMesh</span><span class="p">(</span><span class="n">nInterp</span><span class="p">,</span> <span class="n">Xc</span><span class="p">[</span><span class="n">d</span><span class="p">])</span>
               <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numDims</span><span class="p">)]</span>
  <span class="k">elif</span> <span class="n">gridType</span><span class="o">==</span><span class="s2">&quot;mapped&quot;</span><span class="p">:</span>
    <span class="c1"># back out 1D arrays from Xc.</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numDims</span><span class="p">):</span>
      <span class="n">currSlices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">numDims</span>
      <span class="n">currSlices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[:]</span>
      <span class="n">gridOut</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_makeMesh</span><span class="p">(</span><span class="n">nInterp</span><span class="p">,</span> <span class="n">Xc</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="nb">tuple</span><span class="p">(</span><span class="n">currSlices</span><span class="p">)],</span><span class="n">gridType</span><span class="o">=</span><span class="n">gridType</span><span class="p">))</span>
    <span class="c1">#end</span>
  <span class="c1">#end</span>
  <span class="k">return</span> <span class="n">gridOut</span>

<span class="k">def</span> <span class="nf">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">,</span> <span class="n">qIn</span><span class="p">):</span>
    <span class="n">numCells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">qIn</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="c1"># last entry is indexing nodes, get rid of it</span>
    <span class="n">numCells</span> <span class="o">=</span> <span class="n">numCells</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">numDims</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">numCells</span><span class="p">))</span>
    <span class="n">numInterp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">cMat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">numDims</span><span class="p">)))</span>
    <span class="n">numNodes</span> <span class="o">=</span> <span class="n">cMat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">qOut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">numCells</span><span class="o">*</span><span class="n">numInterp</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
    <span class="c1"># move the node index from last to the first</span>
    <span class="n">qIn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">qIn</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Main loop</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numInterp</span> <span class="o">**</span> <span class="n">numDims</span><span class="p">):</span>
        <span class="c1"># https://docs.scipy.org/doc/numpy/reference/generated/numpy.tensordot.html</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">cMat</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="p">:],</span> <span class="n">qIn</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># decompose n to i,j,k,... indices based on the number of dimensions</span>
        <span class="n">startIdx</span> <span class="o">=</span> <span class="n">_decompose</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">numDims</span><span class="p">,</span> <span class="n">numInterp</span><span class="p">)</span>
        <span class="c1"># define multi-D qOut slices</span>
        <span class="n">idxs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">startIdx</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">numCells</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">numInterp</span><span class="p">),</span> <span class="n">numInterp</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numDims</span><span class="p">)]</span>
        <span class="n">qOut</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">idxs</span><span class="p">)]</span> <span class="o">=</span> <span class="n">temp</span>
    <span class="c1">#end</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">qOut</span><span class="p">)</span>
<span class="c1">#end</span>



<span class="k">class</span> <span class="nc">GInterp</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Postgkyl base class for DG data manipulation.</span>

<span class="sd">    This class should not be used on its own! Currently supported</span>
<span class="sd">    child classes are:</span>
<span class="sd">        - GInterpNodal</span>
<span class="sd">        - GInterpModal</span>

<span class="sd">    Init Args:</span>
<span class="sd">        data (GData): Data to work with</span>
<span class="sd">        numNodes (int): Number of nodes</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">numNodes</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numNodes</span> <span class="o">=</span> <span class="n">numNodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numEqns</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">getNumComps</span><span class="p">()</span><span class="o">/</span><span class="n">numNodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numDims</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">getNumDims</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Xc</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">getGrid</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gridType</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">getGridType</span><span class="p">()</span>
    <span class="c1">#end</span>

    <span class="k">def</span> <span class="nf">_getRawNodal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">):</span>
        <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">getValues</span><span class="p">()</span>
        <span class="n">numEqns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numEqns</span>
        <span class="n">shp</span> <span class="o">=</span> <span class="p">[</span><span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">)]</span>
        <span class="n">shp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numNodes</span><span class="p">)</span>
        <span class="n">rawData</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shp</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numNodes</span><span class="p">):</span>
            <span class="n">rawData</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">component</span><span class="o">+</span><span class="n">n</span><span class="o">*</span><span class="n">numEqns</span><span class="p">)]</span>
        <span class="c1">#end</span>
        <span class="k">return</span> <span class="n">rawData</span>
    <span class="c1">#end</span>

    <span class="k">def</span> <span class="nf">_getRawModal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">):</span>
        <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">getValues</span><span class="p">()</span>
        <span class="n">numEqns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numEqns</span>
        <span class="n">shp</span> <span class="o">=</span> <span class="p">[</span><span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">)]</span>
        <span class="n">shp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numNodes</span><span class="p">)</span>
        <span class="n">rawData</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shp</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="n">lo</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">component</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">numNodes</span><span class="p">)</span>
        <span class="n">up</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">lo</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">numNodes</span><span class="p">)</span>
        <span class="n">rawData</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">lo</span><span class="p">:</span><span class="n">up</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">rawData</span>
    <span class="c1">#end</span>

        
<span class="k">class</span> <span class="nc">GInterpNodal</span><span class="p">(</span><span class="n">GInterp</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Postgkyl class for nodal DG data manipulation.</span>

<span class="sd">    After the initializations, GInterpNodal object provides the</span>
<span class="sd">    interpolate and differentiate methods.  These returns grid and</span>
<span class="sd">    values by default but could be used to directly push to the GData</span>
<span class="sd">    stack with the stack=True flag.</span>

<span class="sd">    Parent: GInterp</span>

<span class="sd">    Init Args:</span>
<span class="sd">        data (GData): Data to work with</span>
<span class="sd">        polyOrder (int): Order of the polynomial approximation</span>
<span class="sd">        basis (str): Specify the basis. Currently supported is the</span>
<span class="sd">            nodal Serendipity &#39;ns&#39;</span>
<span class="sd">        numInterp (int): Specify number of points on which to</span>
<span class="sd">            interpolate (default: polyOrder + 1)</span>
<span class="sd">        read</span>

<span class="sd">    Example:</span>
<span class="sd">        import postgkyl</span>
<span class="sd">        data = postgkyl.GData(&#39;file.h5&#39;)</span>
<span class="sd">        dg = postgkyl.GInterpNodal(data, 2, &#39;ns&#39;)</span>
<span class="sd">        grid, values = dg.interpolate()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">polyOrder</span><span class="p">,</span> <span class="n">basisType</span><span class="p">,</span>
                 <span class="n">numInterp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numDims</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">getNumDims</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span> <span class="o">=</span> <span class="n">polyOrder</span>
        <span class="k">if</span> <span class="n">basisType</span> <span class="o">==</span> <span class="s1">&#39;ns&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">basisType</span> <span class="o">=</span> <span class="s1">&#39;serendipity&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">basisType</span> <span class="o">=</span> <span class="n">basisType</span>
        <span class="c1">#end</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numInterp</span> <span class="o">=</span> <span class="n">numInterp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">read</span>
        <span class="n">numNodes</span> <span class="o">=</span> <span class="n">_getNumNodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basisType</span><span class="p">)</span>
        <span class="n">GInterp</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">numNodes</span><span class="p">)</span>
    <span class="c1">#end</span>

    <span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stack</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">overwrite</span> <span class="o">=</span> <span class="n">stack</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Deprecation warning: The &#39;stack&#39; parameter is going to be replaced with &#39;overwrite&#39;&quot;</span><span class="p">)</span>
        <span class="c1">#end</span>
        <span class="n">cMat</span> <span class="o">=</span> <span class="n">_loadInterpMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">basisType</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numInterp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">nInterp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">cMat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getRawNodal</span><span class="p">(</span><span class="n">comp</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">,</span> <span class="n">q</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getRawNodal</span><span class="p">(</span><span class="n">comp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">,</span> <span class="n">q</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">comp</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getRawNodal</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values</span><span class="p">,</span>
                                   <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">,</span> <span class="n">q</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                                   <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1">#end</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getRawNodal</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">,</span> <span class="n">q</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">start</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">comp</span><span class="o">.</span><span class="n">stop</span><span class="p">):</span>
                <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getRawNodal</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values</span><span class="p">,</span>
                                   <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">,</span> <span class="n">q</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                                   <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1">#end</span>
        <span class="c1">#end</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">_make1Dgrids</span><span class="p">(</span><span class="n">nInterp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">overwrite</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">grid</span><span class="p">,</span> <span class="n">values</span>
        <span class="c1">#end</span>
    <span class="c1">#end</span>

    <span class="k">def</span> <span class="nf">differentiate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stack</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">overwrite</span> <span class="o">=</span> <span class="n">stack</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Deprecation warning: The &#39;stack&#39; parameter is going to be replaced with &#39;overwrite&#39;&quot;</span><span class="p">)</span>
        <span class="c1">#end</span>
        <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getRawNodal</span><span class="p">(</span><span class="n">comp</span><span class="p">)</span>
        <span class="n">cMat</span> <span class="o">=</span> <span class="n">_loadDerivativeMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">basisType</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numInterp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">nInterp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">cMat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">direction</span><span class="p">],</span> <span class="n">q</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">):</span>
                <span class="n">values</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">],</span> <span class="n">q</span><span class="p">)</span>
                <span class="n">values</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1">#end</span>
        <span class="c1">#end</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">_make1Dgrids</span><span class="p">(</span><span class="n">nInterp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">overwrite</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">grid</span><span class="p">,</span> <span class="n">values</span>
        <span class="c1">#end</span>
    <span class="c1">#end</span>
<span class="c1">#end</span>


<span class="k">class</span> <span class="nc">GInterpModal</span><span class="p">(</span><span class="n">GInterp</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Postgkyl class for modal DG data manipulation.</span>

<span class="sd">    After the initializations, GInterpModal object provides the</span>
<span class="sd">    interpolate and differentiate methods.  These returns grid and</span>
<span class="sd">    values by default but could be used to directly push to the GData</span>
<span class="sd">    stack with the stack=True flag.</span>

<span class="sd">    Parent: GInterp</span>

<span class="sd">    Init Args:</span>
<span class="sd">        data (GData): Data to work with</span>
<span class="sd">        polyOrder (int): Order of the polynomial approximation</span>
<span class="sd">        basis (str): Specify the basis. Currently supported are the</span>
<span class="sd">            modal Serendipity &#39;ms&#39; and the maximal order basis &#39;mo&#39;</span>
<span class="sd">        numInterp (int): Specify number of points on which to</span>
<span class="sd">            interpolate (default: polyOrder + 1)</span>
<span class="sd">        read</span>

<span class="sd">    Example:</span>
<span class="sd">        import postgkyl</span>
<span class="sd">        data = postgkyl.GData(&#39;file.bp&#39;)</span>
<span class="sd">        dg = postgkyl.GInterpModal(data, 2, &#39;ms&#39;)</span>
<span class="sd">        grid, values = dg.interpolate()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">polyOrder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">basisType</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">numInterp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">periodic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numDims</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">getNumDims</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">polyOrder</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span> <span class="o">=</span> <span class="n">polyOrder</span>
        <span class="k">elif</span> <span class="n">data</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;polyOrder&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;polyOrder&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;GInterpNodal: polynomial order is neither specified nor stored in the output file&#39;</span><span class="p">)</span>
        <span class="c1">#end</span>
        <span class="k">if</span> <span class="n">basisType</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">basisType</span> <span class="o">==</span> <span class="s1">&#39;ms&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">basisType</span> <span class="o">=</span> <span class="s1">&#39;serendipity&#39;</span>
            <span class="k">elif</span> <span class="n">basisType</span> <span class="o">==</span> <span class="s1">&#39;mo&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">basisType</span> <span class="o">=</span> <span class="s1">&#39;maximal-order&#39;</span>
            <span class="k">elif</span> <span class="n">basisType</span> <span class="o">==</span> <span class="s1">&#39;mt&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">basisType</span> <span class="o">=</span> <span class="s1">&#39;tensor&#39;</span>
            <span class="c1">#end</span>
        <span class="k">elif</span> <span class="n">data</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;basisType&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">basisType</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;basisType&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;GInterpModal: basis type is neither specified nor stored in the output file&#39;</span><span class="p">)</span>
        <span class="c1">#end</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">periodic</span> <span class="o">=</span> <span class="n">periodic</span>
        <span class="k">if</span> <span class="n">numInterp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">numInterp</span> <span class="o">=</span> <span class="n">numInterp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">numInterp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">read</span>
        <span class="n">numNodes</span> <span class="o">=</span> <span class="n">_getNumNodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basisType</span><span class="p">)</span>
        <span class="n">GInterp</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">numNodes</span><span class="p">)</span>
    <span class="c1">#end</span>

    <span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stack</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">overwrite</span> <span class="o">=</span> <span class="n">stack</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Deprecation warning: The &#39;stack&#39; parameter is going to be replaced with &#39;overwrite&#39;&quot;</span><span class="p">)</span>
        <span class="c1">#end</span>
        <span class="n">cMat</span> <span class="o">=</span> <span class="n">_loadInterpMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">basisType</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numInterp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">nInterp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">cMat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getRawModal</span><span class="p">(</span><span class="n">comp</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">,</span> <span class="n">q</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getRawModal</span><span class="p">(</span><span class="n">comp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">,</span> <span class="n">q</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">comp</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getRawModal</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values</span><span class="p">,</span>
                                   <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">,</span> <span class="n">q</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                                   <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1">#end</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getRawModal</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">,</span> <span class="n">q</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">start</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">comp</span><span class="o">.</span><span class="n">stop</span><span class="p">):</span>
                <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getRawModal</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values</span><span class="p">,</span>
                                   <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">,</span> <span class="n">q</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                                   <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1">#end</span>
        <span class="c1">#end</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">_make1Dgrids</span><span class="p">(</span><span class="n">nInterp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gridType</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">overwrite</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">grid</span><span class="p">,</span> <span class="n">values</span>
        <span class="c1">#end</span>
    <span class="c1">#end</span>

    <span class="k">def</span> <span class="nf">differentiate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stack</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">overwrite</span> <span class="o">=</span> <span class="n">stack</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Deprecation warning: The &#39;stack&#39; parameter is going to be replaced with &#39;overwrite&#39;&quot;</span><span class="p">)</span>
        <span class="c1">#end</span>
        <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getRawModal</span><span class="p">(</span><span class="n">comp</span><span class="p">)</span>
        <span class="n">cMat</span> <span class="o">=</span> <span class="n">_loadDerivativeMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">basisType</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numInterp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">nInterp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">cMat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">direction</span><span class="p">],</span> <span class="n">q</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">/=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">):</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">i</span><span class="p">],</span> <span class="n">q</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">)</span>
                <span class="n">values</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1">#end</span>
        <span class="c1">#end</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">_make1Dgrids</span><span class="p">(</span><span class="n">nInterp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gridType</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">overwrite</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">grid</span><span class="p">,</span> <span class="n">values</span>
        <span class="c1">#end</span>
    <span class="c1">#end</span>

    <span class="k">def</span> <span class="nf">recovery</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">c1</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stack</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">overwrite</span> <span class="o">=</span> <span class="n">stack</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Deprecation warning: The &#39;stack&#39; parameter is going to be replaced with &#39;overwrite&#39;&quot;</span><span class="p">)</span>
        <span class="c1">#end</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getRawModal</span><span class="p">(</span><span class="n">comp</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;recovery: only &#39;int&#39; comp implemented so far&quot;</span><span class="p">)</span>
        <span class="c1">#end</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">numDims</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;recovery: only 1D implemented so far&quot;</span><span class="p">)</span>
        <span class="c1">#end</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">numInterp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numInterp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">=</span> <span class="mi">100</span>
        <span class="c1">#end</span>

        <span class="n">numCells</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">getNumCells</span><span class="p">()</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="p">)][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="p">)][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="n">numCells</span><span class="o">*</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">)]</span>

        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">numCells</span><span class="o">*</span><span class="n">N</span><span class="p">)</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">xC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">xL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
        <span class="n">xR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">periodic</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c1</span><span class="p">:</span>
                <span class="n">values</span><span class="p">[:</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="n">recovC1Fn</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="n">xC</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dx</span><span class="p">)</span>
                <span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="n">N</span><span class="p">:]</span> <span class="o">=</span> <span class="n">recovC1Fn</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="n">xC</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dx</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">values</span><span class="p">[:</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="n">recovC0Fn</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="n">xC</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dx</span><span class="p">)</span>
                <span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="n">N</span><span class="p">:]</span> <span class="o">=</span> <span class="n">recovC0Fn</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="n">xC</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dx</span><span class="p">)</span>
            <span class="c1">#end</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">values</span><span class="p">[:</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="n">recovEdFn</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="n">xL</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dx</span><span class="p">)</span>
            <span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="n">N</span><span class="p">:]</span> <span class="o">=</span> <span class="n">recovEdFn</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="n">xR</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dx</span><span class="p">)</span>
        <span class="c1">#end</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">numCells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">c1</span><span class="p">:</span>
                <span class="n">values</span><span class="p">[</span><span class="n">j</span><span class="o">*</span><span class="n">N</span><span class="p">:(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="n">recovC1Fn</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="n">xC</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">dx</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">values</span><span class="p">[</span><span class="n">j</span><span class="o">*</span><span class="n">N</span><span class="p">:(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="n">recovC0Fn</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="n">xC</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">dx</span><span class="p">)</span>
            <span class="c1">#end</span>
        <span class="c1">#end</span>

        <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">overwrite</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">grid</span><span class="p">,</span> <span class="n">values</span>
        <span class="c1">#end</span>
    <span class="c1">#end</span>
<span class="c1">#end</span>
</pre></div>

        </details>

            </section>
                <section id="GInterp">
                                <div class="attr class">
        <a class="headerlink" href="#GInterp">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">GInterp</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">GInterp</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Postgkyl base class for DG data manipulation.</span>

<span class="sd">    This class should not be used on its own! Currently supported</span>
<span class="sd">    child classes are:</span>
<span class="sd">        - GInterpNodal</span>
<span class="sd">        - GInterpModal</span>

<span class="sd">    Init Args:</span>
<span class="sd">        data (GData): Data to work with</span>
<span class="sd">        numNodes (int): Number of nodes</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">numNodes</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numNodes</span> <span class="o">=</span> <span class="n">numNodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numEqns</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">getNumComps</span><span class="p">()</span><span class="o">/</span><span class="n">numNodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numDims</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">getNumDims</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Xc</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">getGrid</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gridType</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">getGridType</span><span class="p">()</span>
    <span class="c1">#end</span>

    <span class="k">def</span> <span class="nf">_getRawNodal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">):</span>
        <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">getValues</span><span class="p">()</span>
        <span class="n">numEqns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numEqns</span>
        <span class="n">shp</span> <span class="o">=</span> <span class="p">[</span><span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">)]</span>
        <span class="n">shp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numNodes</span><span class="p">)</span>
        <span class="n">rawData</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shp</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numNodes</span><span class="p">):</span>
            <span class="n">rawData</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">component</span><span class="o">+</span><span class="n">n</span><span class="o">*</span><span class="n">numEqns</span><span class="p">)]</span>
        <span class="c1">#end</span>
        <span class="k">return</span> <span class="n">rawData</span>
    <span class="c1">#end</span>

    <span class="k">def</span> <span class="nf">_getRawModal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">):</span>
        <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">getValues</span><span class="p">()</span>
        <span class="n">numEqns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numEqns</span>
        <span class="n">shp</span> <span class="o">=</span> <span class="p">[</span><span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">)]</span>
        <span class="n">shp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numNodes</span><span class="p">)</span>
        <span class="n">rawData</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shp</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="n">lo</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">component</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">numNodes</span><span class="p">)</span>
        <span class="n">up</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">lo</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">numNodes</span><span class="p">)</span>
        <span class="n">rawData</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">lo</span><span class="p">:</span><span class="n">up</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">rawData</span>
    <span class="c1">#end</span>
</pre></div>

        </details>

            <div class="docstring"><p>Postgkyl base class for DG data manipulation.</p>

<p>This class should not be used on its own! Currently supported
child classes are:
    - GInterpNodal
    - GInterpModal</p>

<h6 id="init-args">Init Args</h6>

<blockquote>
  <p>data (GData): Data to work with
  numNodes (int): Number of nodes</p>
</blockquote>
</div>


                            <div id="GInterp.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GInterp.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">GInterp</span><span class="signature">(data, numNodes)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">numNodes</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numNodes</span> <span class="o">=</span> <span class="n">numNodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numEqns</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">getNumComps</span><span class="p">()</span><span class="o">/</span><span class="n">numNodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numDims</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">getNumDims</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Xc</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">getGrid</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gridType</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">getGridType</span><span class="p">()</span>
</pre></div>

        </details>

    

                            </div>
                </section>
                <section id="GInterpNodal">
                                <div class="attr class">
        <a class="headerlink" href="#GInterpNodal">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">GInterpNodal</span><wbr>(<span class="base"><a href="#GInterp">GInterp</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">GInterpNodal</span><span class="p">(</span><span class="n">GInterp</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Postgkyl class for nodal DG data manipulation.</span>

<span class="sd">    After the initializations, GInterpNodal object provides the</span>
<span class="sd">    interpolate and differentiate methods.  These returns grid and</span>
<span class="sd">    values by default but could be used to directly push to the GData</span>
<span class="sd">    stack with the stack=True flag.</span>

<span class="sd">    Parent: GInterp</span>

<span class="sd">    Init Args:</span>
<span class="sd">        data (GData): Data to work with</span>
<span class="sd">        polyOrder (int): Order of the polynomial approximation</span>
<span class="sd">        basis (str): Specify the basis. Currently supported is the</span>
<span class="sd">            nodal Serendipity &#39;ns&#39;</span>
<span class="sd">        numInterp (int): Specify number of points on which to</span>
<span class="sd">            interpolate (default: polyOrder + 1)</span>
<span class="sd">        read</span>

<span class="sd">    Example:</span>
<span class="sd">        import postgkyl</span>
<span class="sd">        data = postgkyl.GData(&#39;file.h5&#39;)</span>
<span class="sd">        dg = postgkyl.GInterpNodal(data, 2, &#39;ns&#39;)</span>
<span class="sd">        grid, values = dg.interpolate()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">polyOrder</span><span class="p">,</span> <span class="n">basisType</span><span class="p">,</span>
                 <span class="n">numInterp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numDims</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">getNumDims</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span> <span class="o">=</span> <span class="n">polyOrder</span>
        <span class="k">if</span> <span class="n">basisType</span> <span class="o">==</span> <span class="s1">&#39;ns&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">basisType</span> <span class="o">=</span> <span class="s1">&#39;serendipity&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">basisType</span> <span class="o">=</span> <span class="n">basisType</span>
        <span class="c1">#end</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numInterp</span> <span class="o">=</span> <span class="n">numInterp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">read</span>
        <span class="n">numNodes</span> <span class="o">=</span> <span class="n">_getNumNodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basisType</span><span class="p">)</span>
        <span class="n">GInterp</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">numNodes</span><span class="p">)</span>
    <span class="c1">#end</span>

    <span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stack</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">overwrite</span> <span class="o">=</span> <span class="n">stack</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Deprecation warning: The &#39;stack&#39; parameter is going to be replaced with &#39;overwrite&#39;&quot;</span><span class="p">)</span>
        <span class="c1">#end</span>
        <span class="n">cMat</span> <span class="o">=</span> <span class="n">_loadInterpMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">basisType</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numInterp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">nInterp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">cMat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getRawNodal</span><span class="p">(</span><span class="n">comp</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">,</span> <span class="n">q</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getRawNodal</span><span class="p">(</span><span class="n">comp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">,</span> <span class="n">q</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">comp</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getRawNodal</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values</span><span class="p">,</span>
                                   <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">,</span> <span class="n">q</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                                   <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1">#end</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getRawNodal</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">,</span> <span class="n">q</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">start</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">comp</span><span class="o">.</span><span class="n">stop</span><span class="p">):</span>
                <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getRawNodal</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values</span><span class="p">,</span>
                                   <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">,</span> <span class="n">q</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                                   <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1">#end</span>
        <span class="c1">#end</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">_make1Dgrids</span><span class="p">(</span><span class="n">nInterp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">overwrite</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">grid</span><span class="p">,</span> <span class="n">values</span>
        <span class="c1">#end</span>
    <span class="c1">#end</span>

    <span class="k">def</span> <span class="nf">differentiate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stack</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">overwrite</span> <span class="o">=</span> <span class="n">stack</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Deprecation warning: The &#39;stack&#39; parameter is going to be replaced with &#39;overwrite&#39;&quot;</span><span class="p">)</span>
        <span class="c1">#end</span>
        <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getRawNodal</span><span class="p">(</span><span class="n">comp</span><span class="p">)</span>
        <span class="n">cMat</span> <span class="o">=</span> <span class="n">_loadDerivativeMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">basisType</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numInterp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">nInterp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">cMat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">direction</span><span class="p">],</span> <span class="n">q</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">):</span>
                <span class="n">values</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">],</span> <span class="n">q</span><span class="p">)</span>
                <span class="n">values</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1">#end</span>
        <span class="c1">#end</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">_make1Dgrids</span><span class="p">(</span><span class="n">nInterp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">overwrite</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">grid</span><span class="p">,</span> <span class="n">values</span>
        <span class="c1">#end</span>
    <span class="c1">#end</span>
</pre></div>

        </details>

            <div class="docstring"><p>Postgkyl class for nodal DG data manipulation.</p>

<p>After the initializations, GInterpNodal object provides the
interpolate and differentiate methods.  These returns grid and
values by default but could be used to directly push to the GData
stack with the stack=True flag.</p>

<p>Parent: GInterp</p>

<h6 id="init-args">Init Args</h6>

<blockquote>
  <p>data (GData): Data to work with
  polyOrder (int): Order of the polynomial approximation
  basis (str): Specify the basis. Currently supported is the
      nodal Serendipity 'ns'
  numInterp (int): Specify number of points on which to
      interpolate (default: polyOrder + 1)
  read</p>
</blockquote>

<h6 id="example">Example</h6>

<blockquote>
  <p>import postgkyl
  data = <a href="../../postgkyl.html#GData">postgkyl.GData</a>('file.h5')
  dg = <a href="../../postgkyl.html#GInterpNodal">postgkyl.GInterpNodal</a>(data, 2, 'ns')
  grid, values = dg.interpolate()</p>
</blockquote>
</div>


                            <div id="GInterpNodal.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GInterpNodal.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">GInterpNodal</span><span class="signature">(data, polyOrder, basisType, numInterp=None, read=None)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">polyOrder</span><span class="p">,</span> <span class="n">basisType</span><span class="p">,</span>
                 <span class="n">numInterp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numDims</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">getNumDims</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span> <span class="o">=</span> <span class="n">polyOrder</span>
        <span class="k">if</span> <span class="n">basisType</span> <span class="o">==</span> <span class="s1">&#39;ns&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">basisType</span> <span class="o">=</span> <span class="s1">&#39;serendipity&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">basisType</span> <span class="o">=</span> <span class="n">basisType</span>
        <span class="c1">#end</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numInterp</span> <span class="o">=</span> <span class="n">numInterp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">read</span>
        <span class="n">numNodes</span> <span class="o">=</span> <span class="n">_getNumNodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basisType</span><span class="p">)</span>
        <span class="n">GInterp</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">numNodes</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="GInterpNodal.interpolate" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GInterpNodal.interpolate">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">interpolate</span><span class="signature">(self, comp=0, overwrite=False, stack=False)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stack</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">overwrite</span> <span class="o">=</span> <span class="n">stack</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Deprecation warning: The &#39;stack&#39; parameter is going to be replaced with &#39;overwrite&#39;&quot;</span><span class="p">)</span>
        <span class="c1">#end</span>
        <span class="n">cMat</span> <span class="o">=</span> <span class="n">_loadInterpMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">basisType</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numInterp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">nInterp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">cMat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getRawNodal</span><span class="p">(</span><span class="n">comp</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">,</span> <span class="n">q</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getRawNodal</span><span class="p">(</span><span class="n">comp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">,</span> <span class="n">q</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">comp</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getRawNodal</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values</span><span class="p">,</span>
                                   <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">,</span> <span class="n">q</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                                   <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1">#end</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getRawNodal</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">,</span> <span class="n">q</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">start</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">comp</span><span class="o">.</span><span class="n">stop</span><span class="p">):</span>
                <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getRawNodal</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values</span><span class="p">,</span>
                                   <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">,</span> <span class="n">q</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                                   <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1">#end</span>
        <span class="c1">#end</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">_make1Dgrids</span><span class="p">(</span><span class="n">nInterp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">overwrite</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">grid</span><span class="p">,</span> <span class="n">values</span>
        <span class="c1">#end</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="GInterpNodal.differentiate" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GInterpNodal.differentiate">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">differentiate</span><span class="signature">(self, direction, comp=0, overwrite=False, stack=False)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">differentiate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stack</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">overwrite</span> <span class="o">=</span> <span class="n">stack</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Deprecation warning: The &#39;stack&#39; parameter is going to be replaced with &#39;overwrite&#39;&quot;</span><span class="p">)</span>
        <span class="c1">#end</span>
        <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getRawNodal</span><span class="p">(</span><span class="n">comp</span><span class="p">)</span>
        <span class="n">cMat</span> <span class="o">=</span> <span class="n">_loadDerivativeMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">basisType</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numInterp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">nInterp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">cMat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">direction</span><span class="p">],</span> <span class="n">q</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">):</span>
                <span class="n">values</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">],</span> <span class="n">q</span><span class="p">)</span>
                <span class="n">values</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1">#end</span>
        <span class="c1">#end</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">_make1Dgrids</span><span class="p">(</span><span class="n">nInterp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">overwrite</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">grid</span><span class="p">,</span> <span class="n">values</span>
        <span class="c1">#end</span>
</pre></div>

        </details>

    

                            </div>
                </section>
                <section id="GInterpModal">
                                <div class="attr class">
        <a class="headerlink" href="#GInterpModal">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">GInterpModal</span><wbr>(<span class="base"><a href="#GInterp">GInterp</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">GInterpModal</span><span class="p">(</span><span class="n">GInterp</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Postgkyl class for modal DG data manipulation.</span>

<span class="sd">    After the initializations, GInterpModal object provides the</span>
<span class="sd">    interpolate and differentiate methods.  These returns grid and</span>
<span class="sd">    values by default but could be used to directly push to the GData</span>
<span class="sd">    stack with the stack=True flag.</span>

<span class="sd">    Parent: GInterp</span>

<span class="sd">    Init Args:</span>
<span class="sd">        data (GData): Data to work with</span>
<span class="sd">        polyOrder (int): Order of the polynomial approximation</span>
<span class="sd">        basis (str): Specify the basis. Currently supported are the</span>
<span class="sd">            modal Serendipity &#39;ms&#39; and the maximal order basis &#39;mo&#39;</span>
<span class="sd">        numInterp (int): Specify number of points on which to</span>
<span class="sd">            interpolate (default: polyOrder + 1)</span>
<span class="sd">        read</span>

<span class="sd">    Example:</span>
<span class="sd">        import postgkyl</span>
<span class="sd">        data = postgkyl.GData(&#39;file.bp&#39;)</span>
<span class="sd">        dg = postgkyl.GInterpModal(data, 2, &#39;ms&#39;)</span>
<span class="sd">        grid, values = dg.interpolate()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">polyOrder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">basisType</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">numInterp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">periodic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numDims</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">getNumDims</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">polyOrder</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span> <span class="o">=</span> <span class="n">polyOrder</span>
        <span class="k">elif</span> <span class="n">data</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;polyOrder&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;polyOrder&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;GInterpNodal: polynomial order is neither specified nor stored in the output file&#39;</span><span class="p">)</span>
        <span class="c1">#end</span>
        <span class="k">if</span> <span class="n">basisType</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">basisType</span> <span class="o">==</span> <span class="s1">&#39;ms&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">basisType</span> <span class="o">=</span> <span class="s1">&#39;serendipity&#39;</span>
            <span class="k">elif</span> <span class="n">basisType</span> <span class="o">==</span> <span class="s1">&#39;mo&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">basisType</span> <span class="o">=</span> <span class="s1">&#39;maximal-order&#39;</span>
            <span class="k">elif</span> <span class="n">basisType</span> <span class="o">==</span> <span class="s1">&#39;mt&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">basisType</span> <span class="o">=</span> <span class="s1">&#39;tensor&#39;</span>
            <span class="c1">#end</span>
        <span class="k">elif</span> <span class="n">data</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;basisType&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">basisType</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;basisType&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;GInterpModal: basis type is neither specified nor stored in the output file&#39;</span><span class="p">)</span>
        <span class="c1">#end</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">periodic</span> <span class="o">=</span> <span class="n">periodic</span>
        <span class="k">if</span> <span class="n">numInterp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">numInterp</span> <span class="o">=</span> <span class="n">numInterp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">numInterp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">read</span>
        <span class="n">numNodes</span> <span class="o">=</span> <span class="n">_getNumNodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basisType</span><span class="p">)</span>
        <span class="n">GInterp</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">numNodes</span><span class="p">)</span>
    <span class="c1">#end</span>

    <span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stack</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">overwrite</span> <span class="o">=</span> <span class="n">stack</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Deprecation warning: The &#39;stack&#39; parameter is going to be replaced with &#39;overwrite&#39;&quot;</span><span class="p">)</span>
        <span class="c1">#end</span>
        <span class="n">cMat</span> <span class="o">=</span> <span class="n">_loadInterpMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">basisType</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numInterp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">nInterp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">cMat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getRawModal</span><span class="p">(</span><span class="n">comp</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">,</span> <span class="n">q</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getRawModal</span><span class="p">(</span><span class="n">comp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">,</span> <span class="n">q</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">comp</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getRawModal</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values</span><span class="p">,</span>
                                   <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">,</span> <span class="n">q</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                                   <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1">#end</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getRawModal</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">,</span> <span class="n">q</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">start</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">comp</span><span class="o">.</span><span class="n">stop</span><span class="p">):</span>
                <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getRawModal</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values</span><span class="p">,</span>
                                   <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">,</span> <span class="n">q</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                                   <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1">#end</span>
        <span class="c1">#end</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">_make1Dgrids</span><span class="p">(</span><span class="n">nInterp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gridType</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">overwrite</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">grid</span><span class="p">,</span> <span class="n">values</span>
        <span class="c1">#end</span>
    <span class="c1">#end</span>

    <span class="k">def</span> <span class="nf">differentiate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stack</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">overwrite</span> <span class="o">=</span> <span class="n">stack</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Deprecation warning: The &#39;stack&#39; parameter is going to be replaced with &#39;overwrite&#39;&quot;</span><span class="p">)</span>
        <span class="c1">#end</span>
        <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getRawModal</span><span class="p">(</span><span class="n">comp</span><span class="p">)</span>
        <span class="n">cMat</span> <span class="o">=</span> <span class="n">_loadDerivativeMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">basisType</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numInterp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">nInterp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">cMat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">direction</span><span class="p">],</span> <span class="n">q</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">/=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">):</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">i</span><span class="p">],</span> <span class="n">q</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">)</span>
                <span class="n">values</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1">#end</span>
        <span class="c1">#end</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">_make1Dgrids</span><span class="p">(</span><span class="n">nInterp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gridType</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">overwrite</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">grid</span><span class="p">,</span> <span class="n">values</span>
        <span class="c1">#end</span>
    <span class="c1">#end</span>

    <span class="k">def</span> <span class="nf">recovery</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">c1</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stack</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">overwrite</span> <span class="o">=</span> <span class="n">stack</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Deprecation warning: The &#39;stack&#39; parameter is going to be replaced with &#39;overwrite&#39;&quot;</span><span class="p">)</span>
        <span class="c1">#end</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getRawModal</span><span class="p">(</span><span class="n">comp</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;recovery: only &#39;int&#39; comp implemented so far&quot;</span><span class="p">)</span>
        <span class="c1">#end</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">numDims</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;recovery: only 1D implemented so far&quot;</span><span class="p">)</span>
        <span class="c1">#end</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">numInterp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numInterp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">=</span> <span class="mi">100</span>
        <span class="c1">#end</span>

        <span class="n">numCells</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">getNumCells</span><span class="p">()</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="p">)][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="p">)][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="n">numCells</span><span class="o">*</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">)]</span>

        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">numCells</span><span class="o">*</span><span class="n">N</span><span class="p">)</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">xC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">xL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
        <span class="n">xR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">periodic</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c1</span><span class="p">:</span>
                <span class="n">values</span><span class="p">[:</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="n">recovC1Fn</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="n">xC</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dx</span><span class="p">)</span>
                <span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="n">N</span><span class="p">:]</span> <span class="o">=</span> <span class="n">recovC1Fn</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="n">xC</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dx</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">values</span><span class="p">[:</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="n">recovC0Fn</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="n">xC</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dx</span><span class="p">)</span>
                <span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="n">N</span><span class="p">:]</span> <span class="o">=</span> <span class="n">recovC0Fn</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="n">xC</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dx</span><span class="p">)</span>
            <span class="c1">#end</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">values</span><span class="p">[:</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="n">recovEdFn</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="n">xL</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dx</span><span class="p">)</span>
            <span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="n">N</span><span class="p">:]</span> <span class="o">=</span> <span class="n">recovEdFn</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="n">xR</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dx</span><span class="p">)</span>
        <span class="c1">#end</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">numCells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">c1</span><span class="p">:</span>
                <span class="n">values</span><span class="p">[</span><span class="n">j</span><span class="o">*</span><span class="n">N</span><span class="p">:(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="n">recovC1Fn</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="n">xC</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">dx</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">values</span><span class="p">[</span><span class="n">j</span><span class="o">*</span><span class="n">N</span><span class="p">:(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="n">recovC0Fn</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="n">xC</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">dx</span><span class="p">)</span>
            <span class="c1">#end</span>
        <span class="c1">#end</span>

        <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">overwrite</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">grid</span><span class="p">,</span> <span class="n">values</span>
        <span class="c1">#end</span>
    <span class="c1">#end</span>
</pre></div>

        </details>

            <div class="docstring"><p>Postgkyl class for modal DG data manipulation.</p>

<p>After the initializations, GInterpModal object provides the
interpolate and differentiate methods.  These returns grid and
values by default but could be used to directly push to the GData
stack with the stack=True flag.</p>

<p>Parent: GInterp</p>

<h6 id="init-args">Init Args</h6>

<blockquote>
  <p>data (GData): Data to work with
  polyOrder (int): Order of the polynomial approximation
  basis (str): Specify the basis. Currently supported are the
      modal Serendipity 'ms' and the maximal order basis 'mo'
  numInterp (int): Specify number of points on which to
      interpolate (default: polyOrder + 1)
  read</p>
</blockquote>

<h6 id="example">Example</h6>

<blockquote>
  <p>import postgkyl
  data = <a href="../../postgkyl.html#GData">postgkyl.GData</a>('file.bp')
  dg = <a href="../../postgkyl.html#GInterpModal">postgkyl.GInterpModal</a>(data, 2, 'ms')
  grid, values = dg.interpolate()</p>
</blockquote>
</div>


                            <div id="GInterpModal.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GInterpModal.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">GInterpModal</span><span class="signature">(
    data,
    polyOrder=None,
    basisType=None,
    numInterp=None,
    periodic=False,
    read=None
)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">polyOrder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">basisType</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">numInterp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">periodic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">numDims</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">getNumDims</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">polyOrder</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span> <span class="o">=</span> <span class="n">polyOrder</span>
        <span class="k">elif</span> <span class="n">data</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;polyOrder&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;polyOrder&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;GInterpNodal: polynomial order is neither specified nor stored in the output file&#39;</span><span class="p">)</span>
        <span class="c1">#end</span>
        <span class="k">if</span> <span class="n">basisType</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">basisType</span> <span class="o">==</span> <span class="s1">&#39;ms&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">basisType</span> <span class="o">=</span> <span class="s1">&#39;serendipity&#39;</span>
            <span class="k">elif</span> <span class="n">basisType</span> <span class="o">==</span> <span class="s1">&#39;mo&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">basisType</span> <span class="o">=</span> <span class="s1">&#39;maximal-order&#39;</span>
            <span class="k">elif</span> <span class="n">basisType</span> <span class="o">==</span> <span class="s1">&#39;mt&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">basisType</span> <span class="o">=</span> <span class="s1">&#39;tensor&#39;</span>
            <span class="c1">#end</span>
        <span class="k">elif</span> <span class="n">data</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;basisType&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">basisType</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">meta</span><span class="p">[</span><span class="s1">&#39;basisType&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;GInterpModal: basis type is neither specified nor stored in the output file&#39;</span><span class="p">)</span>
        <span class="c1">#end</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">periodic</span> <span class="o">=</span> <span class="n">periodic</span>
        <span class="k">if</span> <span class="n">numInterp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">numInterp</span> <span class="o">=</span> <span class="n">numInterp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">numInterp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">read</span>
        <span class="n">numNodes</span> <span class="o">=</span> <span class="n">_getNumNodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">basisType</span><span class="p">)</span>
        <span class="n">GInterp</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">numNodes</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="GInterpModal.interpolate" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GInterpModal.interpolate">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">interpolate</span><span class="signature">(self, comp=0, overwrite=False, stack=False)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stack</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">overwrite</span> <span class="o">=</span> <span class="n">stack</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Deprecation warning: The &#39;stack&#39; parameter is going to be replaced with &#39;overwrite&#39;&quot;</span><span class="p">)</span>
        <span class="c1">#end</span>
        <span class="n">cMat</span> <span class="o">=</span> <span class="n">_loadInterpMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">basisType</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numInterp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">nInterp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">cMat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getRawModal</span><span class="p">(</span><span class="n">comp</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">,</span> <span class="n">q</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getRawModal</span><span class="p">(</span><span class="n">comp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">,</span> <span class="n">q</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">comp</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getRawModal</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values</span><span class="p">,</span>
                                   <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">,</span> <span class="n">q</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                                   <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1">#end</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getRawModal</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">,</span> <span class="n">q</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">comp</span><span class="o">.</span><span class="n">start</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">comp</span><span class="o">.</span><span class="n">stop</span><span class="p">):</span>
                <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getRawModal</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values</span><span class="p">,</span>
                                   <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">,</span> <span class="n">q</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                                   <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1">#end</span>
        <span class="c1">#end</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">_make1Dgrids</span><span class="p">(</span><span class="n">nInterp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gridType</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">overwrite</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">grid</span><span class="p">,</span> <span class="n">values</span>
        <span class="c1">#end</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="GInterpModal.differentiate" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GInterpModal.differentiate">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">differentiate</span><span class="signature">(self, direction=None, comp=0, overwrite=False, stack=False)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">differentiate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stack</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">overwrite</span> <span class="o">=</span> <span class="n">stack</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Deprecation warning: The &#39;stack&#39; parameter is going to be replaced with &#39;overwrite&#39;&quot;</span><span class="p">)</span>
        <span class="c1">#end</span>
        <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getRawModal</span><span class="p">(</span><span class="n">comp</span><span class="p">)</span>
        <span class="n">cMat</span> <span class="o">=</span> <span class="n">_loadDerivativeMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">basisType</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numInterp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">nInterp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">cMat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">direction</span><span class="p">],</span> <span class="n">q</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">/=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">):</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">_interpOnMesh</span><span class="p">(</span><span class="n">cMat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">i</span><span class="p">],</span> <span class="n">q</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">)</span>
                <span class="n">values</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1">#end</span>
        <span class="c1">#end</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">_make1Dgrids</span><span class="p">(</span><span class="n">nInterp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gridType</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">overwrite</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">grid</span><span class="p">,</span> <span class="n">values</span>
        <span class="c1">#end</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="GInterpModal.recovery" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GInterpModal.recovery">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">recovery</span><span class="signature">(self, comp=0, c1=False, overwrite=False, stack=False)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">recovery</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">c1</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stack</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">overwrite</span> <span class="o">=</span> <span class="n">stack</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Deprecation warning: The &#39;stack&#39; parameter is going to be replaced with &#39;overwrite&#39;&quot;</span><span class="p">)</span>
        <span class="c1">#end</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getRawModal</span><span class="p">(</span><span class="n">comp</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;recovery: only &#39;int&#39; comp implemented so far&quot;</span><span class="p">)</span>
        <span class="c1">#end</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">numDims</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;recovery: only 1D implemented so far&quot;</span><span class="p">)</span>
        <span class="c1">#end</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">numInterp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numInterp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">=</span> <span class="mi">100</span>
        <span class="c1">#end</span>

        <span class="n">numCells</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">getNumCells</span><span class="p">()</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="p">)][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="p">)][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="n">numCells</span><span class="o">*</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">numDims</span><span class="p">)]</span>

        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">numCells</span><span class="o">*</span><span class="n">N</span><span class="p">)</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">Xc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">xC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">xL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>
        <span class="n">xR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">periodic</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c1</span><span class="p">:</span>
                <span class="n">values</span><span class="p">[:</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="n">recovC1Fn</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="n">xC</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dx</span><span class="p">)</span>
                <span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="n">N</span><span class="p">:]</span> <span class="o">=</span> <span class="n">recovC1Fn</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="n">xC</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dx</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">values</span><span class="p">[:</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="n">recovC0Fn</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="n">xC</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dx</span><span class="p">)</span>
                <span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="n">N</span><span class="p">:]</span> <span class="o">=</span> <span class="n">recovC0Fn</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="n">xC</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dx</span><span class="p">)</span>
            <span class="c1">#end</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">values</span><span class="p">[:</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="n">recovEdFn</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="n">xL</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dx</span><span class="p">)</span>
            <span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="n">N</span><span class="p">:]</span> <span class="o">=</span> <span class="n">recovEdFn</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="n">xR</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dx</span><span class="p">)</span>
        <span class="c1">#end</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">numCells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">c1</span><span class="p">:</span>
                <span class="n">values</span><span class="p">[</span><span class="n">j</span><span class="o">*</span><span class="n">N</span><span class="p">:(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="n">recovC1Fn</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="n">xC</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">dx</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">values</span><span class="p">[</span><span class="n">j</span><span class="o">*</span><span class="n">N</span><span class="p">:(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="n">recovC0Fn</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">polyOrder</span><span class="o">-</span><span class="mi">1</span><span class="p">](</span><span class="n">xC</span><span class="p">,</span> <span class="n">q</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">dx</span><span class="p">)</span>
            <span class="c1">#end</span>
        <span class="c1">#end</span>

        <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">overwrite</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">grid</span><span class="p">,</span> <span class="n">values</span>
        <span class="c1">#end</span>
</pre></div>

        </details>

    

                            </div>
                </section>
    </main>
<script>/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();</script>
<script>
    function escapeHTML(html) {
        return document.createElement('div').appendChild(document.createTextNode(html)).parentNode.innerHTML;
    }

    const originalContent = document.querySelector("main.pdoc");
    let currentContent = originalContent;

    function setContent(innerHTML) {
        let elem;
        if (innerHTML) {
            elem = document.createElement("main");
            elem.classList.add("pdoc");
            elem.innerHTML = innerHTML;
        } else {
            elem = originalContent;
        }
        if (currentContent !== elem) {
            currentContent.replaceWith(elem);
            currentContent = elem;
        }
    }

    function getSearchTerm() {
        return (new URL(window.location)).searchParams.get("search");
    }

    const searchBox = document.querySelector(".pdoc input[type=search]");
    searchBox.addEventListener("input", function () {
        let url = new URL(window.location);
        if (searchBox.value.trim()) {
            url.hash = "";
            url.searchParams.set("search", searchBox.value);
        } else {
            url.searchParams.delete("search");
        }
        history.replaceState("", "", url.toString());
        onInput();
    });
    window.addEventListener("popstate", onInput);


    let searchIndex, searchErr;

    async function initialize() {
        let docs;
        try {
            let resp = await fetch("../../search.json");
            docs = await resp.json();
        } catch (e) {
            searchErr = "Cannot fetch search index.";
            throw e;
        }

        // Also split on html tags. this is a cheap heuristic, but good enough.
        elasticlunr.tokenizer.setSeperator(/[\s\-.;&]+|<[^>]*>/);

        if (docs._isPrebuiltIndex) {
            console.info("using precompiled search index");
            searchIndex = elasticlunr.Index.load(docs);
        } else {
            console.time("building search index");
            searchIndex = elasticlunr(function () {
                this.addField('qualname');
                this.addField('fullname');
                this.addField('doc');
                this.setRef('fullname');
            });
            for (let doc of docs) {
                searchIndex.addDoc(doc);
            }
            console.timeEnd("building search index");
        }
        onInput();

        document.querySelector("nav.pdoc").addEventListener("click", e => {
            if (e.target.hash) {
                searchBox.value = "";
                searchBox.dispatchEvent(new Event("input"));
            }
        });
    }

    function onInput() {
        setContent((() => {
            const search = getSearchTerm();
            if (!search) {
                return null
            }
            if (searchErr) {
                return `<h3>Error: ${searchErr}</h3>`
            }
            if (!searchIndex) {
                return "<h3>Searching...</h3>"
            }

            window.scrollTo({top: 0, left: 0, behavior: 'auto'});

            const results = searchIndex.search(search, {
                fields: {
                    qualname: {boost: 4},
                    fullname: {boost: 2},
                    doc: {boost: 1},
                },
                expand: true
            });

            let html;
            if (results.length === 0) {
                html = `No search results for '${escapeHTML(search)}'.`
            } else {
                html = `<h4>${results.length} search result${results.length > 1 ? "s" : ""} for '${escapeHTML(search)}'.</h4>`;
            }
            for (let result of results.slice(0, 10)) {
                let doc = result.doc;
                let url = `../../${doc.modulename.replaceAll(".", "/")}.html`;
                if (doc.qualname) {
                    url += `#${doc.qualname}`;
                }

                let heading;
                switch (result.doc.type) {
                    case "function":
                        heading = `<span class="def">${doc.funcdef}</span> <span class="name">${doc.fullname}</span><span class="signature">(${doc.parameters.join(", ")})</span>`;
                        break;
                    case "class":
                        heading = `<span class="def">class</span> <span class="name">${doc.fullname}</span>`;
                        break;
                    default:
                        heading = `<span class="name">${doc.fullname}</span>`;
                        break;
                }
                html += `
                        <section class="search-result">
                        <a href="${url}" class="attr ${doc.type}">${heading}</a>
                        <div class="docstring">${doc.doc}</div>
                        </section>
                    `;

            }
            return html;
        })());
    }

    if (getSearchTerm()) {
        initialize();
        searchBox.value = getSearchTerm();
        onInput();
    } else {
        searchBox.addEventListener("focus", initialize, {once: true});
    }

    searchBox.addEventListener("keydown", e => {
        if (["ArrowDown", "ArrowUp", "Enter"].includes(e.key)) {
            let focused = currentContent.querySelector(".search-result.focused");
            if (!focused) {
                currentContent.querySelector(".search-result").classList.add("focused");
            } else if (
                e.key === "ArrowDown"
                && focused.nextElementSibling
                && focused.nextElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.nextElementSibling.classList.add("focused");
                focused.nextElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "ArrowUp"
                && focused.previousElementSibling
                && focused.previousElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.previousElementSibling.classList.add("focused");
                focused.previousElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "Enter"
            ) {
                focused.querySelector("a").click();
            }
        }
    });
</script>